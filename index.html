<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>iCloud</title>
    <!-- CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <!-- PDF.js Library for robust PDF previews -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- JSZip Library for Folder Downloads -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
    /* --- APPLE-ESQUE UI RESET & DEFAULTS --- */
    :root {
        --ios-blue: #007AFF;
        --ios-light-gray: #F2F2F7;
        --ios-mid-gray: #E5E5EA;
        --ios-dark-gray: #8E8E93;
        --ios-red: #FF3B30;
        --ios-green: #34C759;
        --ios-white: #FFFFFF;
        --ios-black: #000000;
        --ios-separator: #C6C6C8;
        --app-bg: var(--ios-light-gray);
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
    }

    html, body {
        height: 100%;
        width: 100%;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background-color: var(--app-bg);
        color: var(--ios-black);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    /* --- SCREEN MANAGEMENT --- */
    .screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transition: opacity 0.3s ease, visibility 0.3s;
        visibility: hidden;
        opacity: 0;
        display: flex;
        flex-direction: column;
        background-color: var(--app-bg);
    }
    .screen.active {
        visibility: visible;
        opacity: 1;
    }
    
    /* --- AUTHENTICATION SCREEN --- */
    #authScreen {
        justify-content: center;
        align-items: center;
        padding: 20px;
        gap: 20px;
        background-color: var(--ios-white);
    }
    #authScreen .app-logo { font-size: 2.5rem; font-weight: bold; color: var(--ios-blue); margin-bottom: 20px; }
    #authScreen .auth-form { width: 100%; max-width: 350px; display: flex; flex-direction: column; gap: 12px; }
    #authScreen h2 { font-size: 1.8rem; font-weight: 600; text-align: center; margin-bottom: 10px; }
    #authScreen input { width: 100%; padding: 14px 16px; border: 1px solid var(--ios-mid-gray); background-color: var(--ios-light-gray); border-radius: 10px; font-size: 1rem; }
    #authScreen input:focus { outline: none; border-color: var(--ios-blue); box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); }
    #authScreen button { width: 100%; padding: 14px; border-radius: 10px; border: none; font-size: 1rem; font-weight: 600; cursor: pointer; color: var(--ios-white); }
    #authScreen #btnLogin { background-color: var(--ios-blue); }
    #authScreen #btnRegister { background-color: var(--ios-green); }
    #authScreen .auth-link { text-align: center; color: var(--ios-blue); cursor: pointer; font-size: 0.9rem; padding: 8px 0; }
    #authScreen .auth-error { color: var(--ios-red); text-align: center; font-size: 0.9rem; min-height: 1.2em; }
    
    /* --- MAIN APP LAYOUT --- */
    #appScreen { background-color: var(--ios-white); }
    .app-header {
        flex-shrink: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        padding-top: calc(12px + env(safe-area-inset-top));
        background-color: rgba(247, 247, 247, 0.8);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-bottom: 1px solid var(--ios-separator);
        z-index: 10;
    }
    .app-header .header-left, .app-header .header-right {
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1;
    }
    .app-header .header-right { justify-content: flex-end; }
    .app-header .header-left { justify-content: flex-start; }
    .app-header .title { font-size: 1.1rem; font-weight: 600; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .app-header .action-icon { font-size: 1.4rem; color: var(--ios-blue); cursor: pointer; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; margin: -10px; }
    .app-content { flex-grow: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; background-color: var(--app-bg); }
    .app-view { display: none; }
    .app-view.active { display: block; }
    .app-bottom-nav { flex-shrink: 0; display: flex; justify-content: space-around; padding-bottom: env(safe-area-inset-bottom); background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-top: 1px solid var(--ios-separator); z-index: 10; }
    .nav-item { flex-grow: 1; padding: 8px 0; text-align: center; cursor: pointer; color: var(--ios-dark-gray); display: flex; flex-direction: column; align-items: center; gap: 2px; transition: color 0.2s; }
    .nav-item i { font-size: 1.5rem; }
    .nav-item span { font-size: 0.7rem; }
    .nav-item.active { color: var(--ios-blue); }

    /* --- UI Components --- */
    .segmented-control { display: flex; padding: 16px; background-color: var(--app-bg); }
    .segmented-control div { flex: 1; text-align: center; padding: 8px; background-color: var(--ios-mid-gray); color: var(--ios-dark-gray); font-weight: 500; cursor: pointer; transition: background-color 0.2s, color 0.2s; }
    .segmented-control div:first-child { border-radius: 8px 0 0 8px; }
    .segmented-control div:last-child { border-radius: 0 8px 8px 0; }
    .segmented-control div.active { background-color: var(--ios-blue); color: var(--ios-white); }

    /* --- VAULT VIEW --- */
    .storage-stats-container {
        padding: 12px 16px;
        background-color: var(--ios-white);
        border-bottom: 1px solid var(--ios-separator);
    }
    .total-storage-info { font-size: 1rem; font-weight: 500; margin-bottom: 10px; color: var(--ios-black); }
    .total-storage-info strong { font-weight: 600; color: var(--ios-blue); }
    .storage-breakdown { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 8px; }
    .stat-item { background-color: var(--app-bg); padding: 6px 10px; border-radius: 6px; display: flex; flex-direction: column; }
    .stat-item .stat-category { font-weight: 500; color: var(--ios-dark-gray); font-size: 0.8rem; }
    .stat-item .stat-details { font-size: 0.75rem; }
    
    /* --- LIST VIEW STYLES --- */
    .file-list { list-style: none; background-color: var(--ios-white); }
    .file-list .file-item { display: flex; align-items: center; padding: 12px 16px; border-bottom: 1px solid var(--ios-separator); cursor: pointer; }
    .file-list .file-item:last-child { border-bottom: none; }
    .file-list .file-icon { font-size: 1.8rem; width: 0px; text-align: center; margin-right: 50px; }
    .file-list .file-icon i.fa-folder { color: #82C1FF; } /* Default color for list view */
    .file-list .file-details { flex-grow: 1; overflow: hidden; }
    .file-list .file-name { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .file-list .file-size { font-size: 0.8rem; color: var(--ios-dark-gray); }
    .file-list .file-action-icon { font-size: 1.2rem; color: var(--ios-dark-gray); padding: 8px 12px; margin: -8px -12px; cursor: pointer; }
    
    /* --- GRID VIEW STYLES --- */
    .file-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 24px;
        padding: 16px;
        list-style: none;
        background-color: transparent;
    }
    .file-grid .file-item {
        display: flex;
        flex-direction: column;
        cursor: pointer;
        padding: 0;
        border-bottom: none;
    }

    .fa-ellipsis-v:before, .fa-ellipsis-vertical:before {
content: "\f142";
color: white;}
    .file-grid .file-preview {
        position: relative;
        width: 100%;
        aspect-ratio: 4 / 3;
        background-color: var(--ios-white);
        border: 1px solid var(--ios-separator);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 8px;
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }
    .file-grid .file-preview i.fa-folder { color: #82C1FF; }
    .file-grid .file-preview i { font-size: 1.7rem; color: var(--ios-dark-gray); }
    .file-grid .file-preview img { width: 100%; height: 100%; object-fit: cover; }
    .file-grid .grid-action-btn { position: absolute; top: 6px; right: 6px; width: 28px; height: 28px; background-color: rgba(0, 0, 0, 0.3); color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.9rem; cursor: pointer; transition: background-color 0.2s; transform: rotate(90deg); z-index: 5; }
    .file-grid .grid-action-btn:hover { background-color: rgba(0, 0, 0, 0.5); }
    .file-grid .file-details { overflow: hidden; }
    .file-grid .file-name { font-weight: 400; font-size: 0.9rem; color: var(--ios-black); white-space: normal; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; line-height: 1.3; margin-bottom: 2px; }
    .file-grid .file-size { font-size: 0.8rem; color: var(--ios-dark-gray); }



    .file-grid .file-preview i.fa-folder,  i.fa-solid.fa-book ,i.fa-solid.fa-star, i.fa-solid.fa-heart, i.fa-solid.fa-camera, i.fa-solid.fa-briefcase, i.fa-solid.fa-car, i.fa-solid.fa-plane, i.fa-solid.fa-key, i.fa-solid.fa-lightbulb, i.fa-solid.fa-file-audio, i.fa-solid.fa-file-image, i.fa-solid.fa-file-video, i.fa-solid.fa-file-pdf{
        font-size: 2.5rem; 
        color: rgb(201, 201, 201);
    }

    /* logout icon */
    .fa-arrow-right-from-bracket:before, .fa-sign-out:before {
    content: "\f08b";
    color: red;
}

    /* --- SHARE VIEW --- */
    #share-view .content-padding { padding: 16px; }
    .drop-zone { border-radius: 12px; padding: 40px 20px; text-align: center; cursor: pointer; margin-bottom: 16px; }
    .drop-zone i, #ShareIcon { font-size: 3rem; color: var(--ios-blue); margin-bottom: 12px; align-items: center; justify-content: center; display: flex; }
    .drop-zone p { margin: 4px 0; color: var(--ios-dark-gray); }
    .ios-button { width: 100%; padding: 14px; border-radius: 10px; border: none; font-size: 1rem; font-weight: 600; cursor: pointer; background-color: var(--ios-blue); color: var(--ios-white); display: flex; align-items: center; justify-content: center; gap: 8px; }
    .ios-button.secondary { background-color: var(--ios-mid-gray); color: var(--ios-blue); }
    .ios-button:disabled { background-color: var(--ios-mid-gray); color: var(--ios-dark-gray); cursor: not-allowed; }
    .or-divider { text-align: center; color: var(--ios-dark-gray); margin: 20px 0; }
    .selected-file-display { display: flex; align-items: center; justify-content: space-between; background: var(--ios-white); padding: 12px; border-radius: 10px; margin-bottom: 16px; }
    .selected-file-display i { color: var(--ios-green); margin-right: 8px; }
    .selected-file-display span { font-weight: 500; }
    .selected-file-display .clear-btn { color: var(--ios-red); cursor: pointer; }
    .input-group { margin-bottom: 16px; }
    .input-group input, .modal-body input { width: 100%; padding: 14px 16px; border: 1px solid var(--ios-mid-gray); background-color: var(--ios-light-gray); border-radius: 10px; font-size: 1rem; }
    .input-group input:focus, .modal-body input:focus { outline: none; border-color: var(--ios-blue); box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); }
    .progress-container { margin: 16px 0; }
    .progress-bar-track { width: 100%; height: 6px; background-color: var(--ios-mid-gray); border-radius: 3px; overflow: hidden; }
    .progress-bar-fill { width: 0%; height: 100%; background-color: var(--ios-blue); border-radius: 3px; transition: width 0.3s ease; }
    .incoming-file-list { list-style: none; background-color: var(--ios-white); border-radius: 12px; overflow: hidden; border: 1px solid var(--ios-mid-gray); }
    .incoming-file-item { display: flex; align-items: center; padding: 12px 16px; border-bottom: 1px solid var(--ios-separator); }
    .incoming-file-actions button { width: 36px; height: 36px; border-radius: 50%; border: none; color: white; font-size: 1rem; cursor: pointer; margin-left: 8px; }
    .incoming-file-actions .accept-btn { background-color: var(--ios-green); }
    .incoming-file-actions .reject-btn { background-color: var(--ios-red); }

    /* --- MODALS --- */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); z-index: 100; display: flex; opacity: 0; visibility: hidden; transition: opacity 0.3s ease; }
    .modal-overlay.visible { opacity: 1; visibility: visible; }
    
    #action-sheet-modal .modal-content { position: absolute; bottom: 0; width: 100%; padding: 16px; padding-bottom: calc(16px + env(safe-area-inset-bottom)); transform: translateY(100%); transition: transform 0.3s ease-out; }
    #action-sheet-modal.visible .modal-content { transform: translateY(0); }
    .action-sheet-group { background: rgba(249, 249, 249, 0.94); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 14px; margin-bottom: 8px; }
    .action-sheet-group button { width: 100%; padding: 16px; background: transparent; border: none; border-bottom: 1px solid var(--ios-separator); font-size: 1.1rem; color: var(--ios-blue); cursor: pointer; }
    .action-sheet-group button:last-child { border-bottom: none; }
    .action-sheet-group .delete-action { color: var(--ios-red); }
    .action-sheet-group.cancel-group button { font-weight: 600; }

    .centered-modal .modal-content { background: var(--ios-white); margin: auto; border-radius: 14px; width: 90%; max-width: 500px; max-height: 80vh; display: flex; flex-direction: column; transform: scale(0.95); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease; }
    .centered-modal.visible .modal-content { transform: scale(1); opacity: 1; }
    .modal-header { padding: 16px; border-bottom: 1px solid var(--ios-separator); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
    .modal-header h3 { font-size: 1.1rem; font-weight: 600; }
    .modal-close-btn { font-size: 1.5rem; cursor: pointer; color: var(--ios-dark-gray); }
    .modal-body { overflow-y: auto; flex-grow: 1; padding: 16px; }
    #previewModal .modal-body { text-align: center; padding: 10px; }
    #previewModal .modal-body img { max-width: 100%; max-height: 100%; object-fit: contain; }
    #previewModal .modal-body canvas { border: 1px solid var(--ios-mid-gray); max-width: 100%; height: auto !important; }
    .modal-footer { flex-shrink: 0; display: flex; padding: 10px 16px; border-top: 1px solid var(--ios-separator); gap: 10px; }
    .modal-footer button { flex-grow: 1; }
    #pdfControls { justify-content: space-between; align-items: center; }
    #pdfControls button { flex-grow: 0; width: auto; padding: 8px 16px; font-size: 0.9rem; }
    
    #folderIconSelector { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 16px; margin-top: 16px; }
    .icon-choice { width: 100%; aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; border: 2px solid var(--ios-mid-gray); border-radius: 10px; cursor: pointer; transition: all 0.2s ease; }
    .icon-choice i { font-size: 1.8rem; color: var(--ios-dark-gray); }
    .icon-choice.selected { border-color: var(--ios-blue); background-color: #e5f1ff; }
    .icon-choice.selected i { color: var(--ios-blue); }
    #newFolderColorInput { width: 100%; height: 44px; border: 1px solid var(--ios-mid-gray); padding: 5px; border-radius: 10px; background-color: var(--ios-light-gray); cursor: pointer; }


    /* Toast Notifications */
    #toastContainer { position: fixed; top: calc(16px + env(safe-area-inset-top)); left: 50%; transform: translateX(-50%); z-index: 200; display: flex; flex-direction: column; align-items: center; gap: 8px; }
    .toast { padding: 10px 20px; border-radius: 20px; color: white; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; transform: translateY(-20px); transition: opacity 0.3s ease, transform 0.3s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
    .toast.success { background-color: var(--ios-green); }
    .toast.error { background-color: var(--ios-red); }
    .toast.info { background-color: var(--ios-dark-gray); }

</style>
</head>
<body>

    <!-- Authentication Screen -->
<div id="authScreen" class="screen active">
    <div class="app-logo">iCloud</div>
    <div id="loginForm" class="auth-form">
        <h2>Sign In</h2>
        <input type="email" id="loginEmailInput" placeholder="Email" autocomplete="email">
        <input type="password" id="loginPasswordInput" placeholder="Password" autocomplete="current-password">
        <p id="authError" class="auth-error"></p>
        <button id="btnLogin">Sign In</button>
        <p id="showRegisterLink" class="auth-link">Don't have an account? Sign Up</p>
    </div>
    <div id="registerForm" class="auth-form" style="display: none;">
        <h2>Create Account</h2>
        <input type="email" id="registerEmailInput" placeholder="Email" autocomplete="email">
        <input type="password" id="registerPasswordInput" placeholder="Password" autocomplete="new-password">
        <p id="registerError" class="auth-error"></p>
        <button id="btnRegister">Sign Up</button>
        <p id="showLoginLink" class="auth-link">Already have an account? Sign In</p>
    </div>
</div>

<!-- Main Application Screen -->
<div id="appScreen" class="screen">
    <header class="app-header">
        <div class="header-left">
             <i class="fa-solid fa-arrow-left action-icon" id="btnBack" style="display: none;"></i>
             <i class="fa-solid fa-arrow-right-from-bracket action-icon" id="btnLogout"></i>
        </div>
        <h1 class="title" id="appTitle">iCloud</h1>
        <div class="header-right">
            <i class="fa-solid fa-grip action-icon" id="btnViewToggle" style="display: none;"></i>
            <i class="fa-solid fa-folder-plus action-icon" id="btnCreateFolder"></i>
            <i class="fa-solid fa-plus action-icon" id="btnShowUpload"></i>
        </div>
        <input type="file" id="fileInput" hidden>
    </header>

    <main class="app-content">
        <!-- Vault View -->
        <div id="vault-view" class="app-view active">
             <div class="segmented-control" id="fileFilterButtons">
                <div class="active" data-filter="all">All</div>
                <div data-filter="image">Images</div>
                <div data-filter="video">Videos</div>
                <div data-filter="doc">Docs</div>
            </div>
            <div id="storageStats" class="storage-stats-container"></div>
            <ul id="fileList"></ul>
        </div>
        <!-- Share View -->
        <div id="share-view" class="app-view">
            <div class="segmented-control" id="shareModeToggle">
                <div class="active" data-mode="send">Send</div>
                <div data-mode="inbox">Inbox</div>
            </div>
            <div id="share-send-mode">
                <div class="content-padding">
                    <label for="shareFileInput" class="drop-zone">
                       <span id="ShareIcon"> <svg xmlns="http://www.w3.org/2000/svg" height="70px" viewBox="0 -960 960 960" width="70px" fill="#006eff"><path d="M250-160q-86 0-148-62T40-370q0-78 49.5-137.5T217-579q20-97 94-158.5T482-799q113 0 189.5 81.5T748-522v24q72-2 122 46.5T920-329q0 69-50 119t-119 50H510q-24 0-42-18t-18-42v-258l-83 83-43-43 156-156 156 156-43 43-83-83v258h241q45 0 77-32t32-77q0-45-32-77t-77-32h-63v-84q0-89-60.5-153T478-739q-89 0-150 64t-61 153h-19q-62 0-105 43.5T100-371q0 62 43.93 106.5T250-220h140v60H250Zm230-290Z"/></svg> </span> 
                        <p>Tap to select file</p>
                        <p style="font-size: 0.8rem;">or drag & drop</p>
                    </label>
                    <input type="file" id="shareFileInput" hidden>
                    <div class="or-divider">or</div>
                    <button id="selectFromVaultBtn" class="ios-button secondary">
                        <i class="fa-solid fa-cloud"></i>
                        Select from iCloud
                    </button>
                    <div id="selectedShareFileDisplay" class="selected-file-display" style="display: none; margin-top: 16px;">
                       <div><i class="fa-solid fa-circle-check"></i> <span id="selectedFileName"></span></div>
                       <i id="clearSelectionBtn" class="fa-solid fa-circle-xmark clear-btn"></i>
                    </div>
                    <div class="input-group" style="margin-top: 24px;">
                        <input type="email" id="receiverEmail" placeholder="Receiver's Email">
                    </div>
                    <div id="progressContainer" class="progress-container" style="display: none;">
                       <div class="progress-bar-track"><div id="progressBar" class="progress-bar-fill"></div></div>
                    </div>
                    <button id="sendButton" class="ios-button">
                         <i class="fa-solid fa-paper-plane"></i>
                        <span>Send File</span>
                    </button>
                </div>
            </div>
            <div id="share-inbox-mode" style="display: none;">
                <ul class="incoming-file-list" id="incomingFiles"></ul>
            </div>
        </div>
    </main>
    
    <nav class="app-bottom-nav">
        <div id="vaultTabBtn" class="nav-item active">
            <i class="fa-solid fa-box-archive"></i>
            <span>Vault</span>
        </div>
        <div id="shareTabBtn" class="nav-item">
            <i class="fa-solid fa-share-nodes"></i>
            <span>Share</span>
        </div>
    </nav>
</div>

<!-- Modals -->
<div id="action-sheet-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="action-sheet-group">
            <button id="actionPreview">Preview</button>
            <button id="actionDownload">Download</button>
            <button id="actionDelete" class="delete-action">Delete</button>
        </div>
        <div class="action-sheet-group cancel-group">
            <button id="actionCancel">Cancel</button>
        </div>
    </div>
</div>

<div id="vaultSelectModal" class="modal-overlay centered-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Select from Vault</h3>
            <i id="closeVaultSelectModal" class="fa-solid fa-xmark modal-close-btn"></i>
        </div>
        <div class="modal-body">
            <ul class="file-list" id="vaultFileListForSharing"></ul>
        </div>
    </div>
</div>

<div id="previewModal" class="modal-overlay centered-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="modalTitle">File Preview</h3>
            <i id="closePreviewModal" class="fa-solid fa-xmark modal-close-btn"></i>
        </div>
        <div class="modal-body" id="modalBody"></div>
        <div class="modal-footer" id="pdfControls" style="display: none;">
            <button id="pdfPrev" class="ios-button secondary">Prev</button>
            <span id="pdfPageInfo"></span>
            <button id="pdfNext" class="ios-button secondary">Next</button>
        </div>
    </div>
</div>

<div id="folderCreationModal" class="modal-overlay centered-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>New Folder</h3>
            <i class="fa-solid fa-xmark modal-close-btn"></i>
        </div>
        <div class="modal-body">
            <input type="text" id="newFolderNameInput" placeholder="Folder Name">
             <!-- NEW: Color Picker -->
            <div class="input-group" style="margin-top: 16px;">
                <label for="newFolderColorInput" style="display: block; margin-bottom: 8px; font-weight: 500;">Folder Color</label>
                <input type="color" id="newFolderColorInput" value="#007AFF">
            </div>
            <div id="folderIconSelector"></div>
        </div>
        <div class="modal-footer">
            <button id="cancelFolderCreationBtn" class="ios-button secondary">Cancel</button>
            <button id="confirmFolderCreationBtn" class="ios-button">Create</button>
        </div>
    </div>
</div>

<div id="toastContainer"></div>

<script type="module">
    // --- FIREBASE IMPORTS ---
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getDatabase, ref, get, set, push, onValue, update, remove } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

    // --- CONFIGURATION ---
    const MeraKamara = [
        { owner: 'HarshPahal', token: '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' },
        { owner: 'Harsh-Kumar-Pahal', token: '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' },
    ];
    const GuptDwarKiChabi = 'YOUR_SUPER_STRONG_AND_SECRET_KEY_GOES_HERE'; 
    const firebaseConfig = {
        apiKey: "AIzaSyDB_ylrW7hartjCjSAqjjZjUoNSrSX7Et4",
        authDomain: "blogs-a7325.firebaseapp.com",
        databaseURL: "https://blogs-a7325-default-rtdb.firebaseio.com",
        projectId: "blogs-a7325",
        storageBucket: "blogs-a7325.appspot.com",
        messagingSenderId: "868013133674",
        appId: "1:868013133674:web:8ceaa7dfa63ee0d2a0df13",
        measurementId: "G-RJX09FKMMY"
    };
    const PRIMARY_GITHUB_ACCOUNT = MeraKamara[0];
    const MAIN_REPO_BASE_NAME = 'secure-file-vault';
    const CENTER_INDEX_FILE = 'centerIndex.json';
    const REPO_SIZE_LIMIT_GB = 95;
    const LARGE_FILE_THRESHOLD_MB = 1;
    const CHUNK_SIZE = 1024 * 1024;
    const FOLDER_META_FILENAME = '__.folder_meta.json';
    const FOLDER_ICONS = ['fa-solid fa-folder', 'fa-solid fa-star', 'fa-solid fa-heart', 'fa-solid fa-book', 'fa-solid fa-camera', 'fa-solid fa-briefcase', 'fa-solid fa-car', 'fa-solid fa-plane', 'fa-solid fa-key', 'fa-solid fa-lightbulb'];

    // --- FIREBASE INITIALIZATION ---
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const database = getDatabase(app);
    
    // --- GLOBAL STATE ---
    let currentUser = null;
    let currentPathStack = [];
    let currentFilter = 'all';
    let fileToShare = null;
    let currentActionItem = null;
    let currentView = localStorage.getItem('fileView') || 'grid';
    let pdfPreviewState = { pdfDoc: null, pageNum: 1, pageRendering: false, pageNumPending: null };
    let selectedFolderIcon = FOLDER_ICONS[0];

    // --- PDF.js Worker Configuration ---
    if (window.pdfjsLib) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    // --- UI ELEMENTS ---
    const authScreen = document.getElementById('authScreen');
    const loginForm = document.getElementById('loginForm'), registerForm = document.getElementById('registerForm');
    const loginEmailInput = document.getElementById('loginEmailInput'), loginPasswordInput = document.getElementById('loginPasswordInput');
    const registerEmailInput = document.getElementById('registerEmailInput'), registerPasswordInput = document.getElementById('registerPasswordInput');
    const btnLogin = document.getElementById('btnLogin'), btnRegister = document.getElementById('btnRegister');
    const authError = document.getElementById('authError'), registerError = document.getElementById('registerError');
    const showRegisterLink = document.getElementById('showRegisterLink'), showLoginLink = document.getElementById('showLoginLink');
    const btnLogout = document.getElementById('btnLogout'), appTitle = document.getElementById('appTitle');
    const btnBack = document.getElementById('btnBack'), btnCreateFolder = document.getElementById('btnCreateFolder');
    const btnShowUpload = document.getElementById('btnShowUpload'), fileInput = document.getElementById('fileInput');
    const vaultTabBtn = document.getElementById('vaultTabBtn'), shareTabBtn = document.getElementById('shareTabBtn');
    const fileListUl = document.getElementById('fileList'), fileFilterButtons = document.getElementById('fileFilterButtons');
    const shareModeToggle = document.getElementById('shareModeToggle'), shareSendMode = document.getElementById('share-send-mode'), shareInboxMode = document.getElementById('share-inbox-mode');
    const shareFileInput = document.getElementById('shareFileInput'), receiverEmailInput = document.getElementById('receiverEmail');
    const sendButton = document.getElementById('sendButton'), progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const incomingFilesDiv = document.getElementById('incomingFiles');
    const selectFromVaultBtn = document.getElementById('selectFromVaultBtn');
    const selectedShareFileDisplay = document.getElementById('selectedShareFileDisplay');
    const selectedFileName = document.getElementById('selectedFileName');
    const clearSelectionBtn = document.getElementById('clearSelectionBtn');
    const vaultSelectModal = document.getElementById('vaultSelectModal');
    const previewModal = document.getElementById('previewModal');
    const vaultFileListForSharing = document.getElementById('vaultFileListForSharing');
    const pdfControls = document.getElementById('pdfControls');
    const pdfPrevBtn = document.getElementById('pdfPrev');
    const pdfNextBtn = document.getElementById('pdfNext');
    const pdfPageInfo = document.getElementById('pdfPageInfo');
    const storageStatsContainer = document.getElementById('storageStats');
    const btnViewToggle = document.getElementById('btnViewToggle');
    const folderCreationModal = document.getElementById('folderCreationModal');
    const newFolderNameInput = document.getElementById('newFolderNameInput');
    const newFolderColorInput = document.getElementById('newFolderColorInput');
    const folderIconSelector = document.getElementById('folderIconSelector');
    const confirmFolderCreationBtn = document.getElementById('confirmFolderCreationBtn');
    const cancelFolderCreationBtn = document.getElementById('cancelFolderCreationBtn');
    
    // --- UTILITY & UI FUNCTIONS ---
    // (FIXED) showToast now supports an ID to update existing toasts, preventing selector errors and improving UX for progress updates.
    const showToast = (message, type = 'info', options = {}) => {
        const { duration = 3000, id = null } = options;
        if (id) {
            const existingToast = document.getElementById(id);
            if (existingToast) {
                existingToast.className = `toast ${type} show`;
                existingToast.textContent = message;
                return;
            }
        }
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        if (id) {
            toast.id = id;
        }
        document.getElementById('toastContainer').appendChild(toast);
        setTimeout(() => toast.classList.add('show'), 10);

        if (duration > 0) {
            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }
    };
    const formatBytes = (bytes, decimals = 2) => {
        if (!+bytes) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
    }
    const getFileCategory = (fileName) => {
        const ext = fileName.split('.').pop().toLowerCase();
        const categoryMap = {
            Images: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'],
            Videos: ['mp4', 'avi', 'mov', 'mkv', 'webm'],
            Docs: ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'csv'],
            Audio: ['mp3', 'wav', 'ogg', 'm4a'],
            Archives: ['zip', 'rar', '7z', 'tar', 'gz']
        };
        for (const category in categoryMap) { if (categoryMap[category].includes(ext)) return category; }
        return 'Others';
    };

    const showScreen = (screenId) => { document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); document.getElementById(screenId).classList.add('active'); };
    const showAuthForm = (formToShow) => { loginForm.style.display = formToShow === 'login' ? 'flex' : 'none'; registerForm.style.display = formToShow === 'register' ? 'flex' : 'none'; authError.textContent = ''; registerError.textContent = ''; };
    showRegisterLink.onclick = () => showAuthForm('register'); showLoginLink.onclick = () => showAuthForm('login');
    const showAppView = (viewId) => { 
        document.querySelectorAll('.app-view').forEach(v => v.classList.remove('active')); 
        document.getElementById(viewId).classList.add('active'); 
        const isVault = viewId === 'vault-view'; 
        btnShowUpload.style.display = isVault ? 'flex' : 'none';
        btnCreateFolder.style.display = isVault ? 'flex' : 'none';
        btnViewToggle.style.display = isVault ? 'flex' : 'none';
        vaultTabBtn.classList.toggle('active', isVault); 
        shareTabBtn.classList.toggle('active', !isVault); 
        updateHeaderUI();
    };
    vaultTabBtn.onclick = () => showAppView('vault-view'); shareTabBtn.onclick = () => showAppView('share-view');
    const showModal = (modalId) => document.getElementById(modalId).classList.add('visible');
    const hideModal = (modalId) => document.getElementById(modalId).classList.remove('visible');
    const updateHeaderUI = () => {
        const isVault = document.getElementById('vault-view').classList.contains('active');
        if (isVault) {
            appTitle.textContent = currentPathStack.length > 0 ? currentPathStack[currentPathStack.length-1] : 'My Vault';
            btnBack.style.display = currentPathStack.length > 0 ? 'flex' : 'none';
            btnLogout.style.display = currentPathStack.length > 0 ? 'none' : 'flex';
        } else {
            appTitle.textContent = 'Share Files';
            btnBack.style.display = 'none';
            btnLogout.style.display = 'flex';
        }
    };

    // --- AUTHENTICATION ---
    onAuthStateChanged(auth, async (user) => { if (user) { const userRef = ref(database, `dropit_users/${user.uid}/online`); set(userRef, true); window.addEventListener('beforeunload', () => set(userRef, false)); const vaultData = await loadUserVaultData(user); currentUser = { uid: user.uid, email: user.email, vaultInfo: vaultData }; showScreen('appScreen'); showAppView('vault-view'); updateView(); setupFileListeners(user); } else { currentUser = null; currentPathStack = []; showScreen('authScreen'); showAuthForm('login'); fileListUl.innerHTML = ''; incomingFilesDiv.innerHTML = ''; } });
    btnRegister.onclick = async () => { const email = registerEmailInput.value.trim(), password = registerPasswordInput.value; registerError.textContent = ''; try { const userCredential = await createUserWithEmailAndPassword(auth, email, password); await provisionGitHubVaultForNewUser(userCredential.user); await set(ref(database, 'dropit_users/' + userCredential.user.uid), { email: email, online: true }); showToast('Registration successful!', 'success'); } catch (error) { registerError.textContent = error.message; } };
    btnLogin.onclick = async () => { const email = loginEmailInput.value.trim(), password = loginPasswordInput.value; authError.textContent = ''; try { await signInWithEmailAndPassword(auth, email, password); showToast('Login successful!', 'success'); } catch (error) { authError.textContent = error.message; } };
    btnLogout.onclick = () => { const user = auth.currentUser; if (user) set(ref(database, `dropit_users/${user.uid}/online`), false).then(() => signOut(auth)); else signOut(auth); };

    // ======================== GITHUB VAULT LOGIC ========================
    async function githubApi(path, method = 'GET', body = null, token) {if (!token) throw new Error("API call requires a token.");const url = `https://api.github.com${path}`;const headers = { 'Authorization': `Bearer ${token}`, 'Accept': 'application/vnd.github.v3+json' };const options = { method, headers, cache: 'no-cache' };if (body) options.body = JSON.stringify(body);const res = await fetch(url, options);if (!res.ok) {if (res.status === 404) return { data: null, status: 404 };if (res.status === 422) return { data: null, status: 422 };if (res.status === 409) { const error = await res.json().catch(() => ({ message: res.statusText })); throw new Error(`Conflict (409): ${error.message || 'Stale data'}`); }const error = await res.json().catch(() => ({ message: res.statusText }));throw new Error(`${method} ${path} â†’ ${res.status}: ${error.message || 'Unknown error'}`);}if ([201, 204].includes(res.status)) return { data: await res.json().catch(() => null), status: res.status };return { data: await res.json(), status: res.status };}
    async function getJsonFile(owner, repo, path, token) {const { data, status } = await githubApi(`/repos/${owner}/${repo}/contents/${path}`, 'GET', null, token);if (status === 404) return { content: null, sha: null };return { content: JSON.parse(atob(data.content)), sha: data.sha };}
    async function provisionGitHubVaultForNewUser(user) { const { content: centralIndex, sha: indexSha } = await getJsonFile(PRIMARY_GITHUB_ACCOUNT.owner, MAIN_REPO_BASE_NAME, CENTER_INDEX_FILE, PRIMARY_GITHUB_ACCOUNT.token); const users = centralIndex || {}; if (users[user.email]) { return; } const accountIndex = Math.floor(Math.random() * MeraKamara.length); const chosenAccount = MeraKamara[accountIndex]; const firstRepoName = `${MAIN_REPO_BASE_NAME}-${user.uid.substring(0, 8)}-1`; await githubApi('/user/repos', 'POST', { name: firstRepoName, private: true }, chosenAccount.token); users[user.email] = { repositories: [{ owner: chosenAccount.owner, name: firstRepoName, accountIndex: accountIndex }] }; const b64content = btoa(JSON.stringify(users, null, 2)); const message = `feat: Register new user ${user.email}`; await githubApi(`/repos/${PRIMARY_GITHUB_ACCOUNT.owner}/${MAIN_REPO_BASE_NAME}/contents/${CENTER_INDEX_FILE}`, 'PUT', { message, content: b64content, sha: indexSha }, PRIMARY_GITHUB_ACCOUNT.token); await githubApi(`/repos/${chosenAccount.owner}/${firstRepoName}/contents/${user.email}/.gitkeep`, 'PUT', { message: `chore: Create initial folder for ${user.email}`, content: btoa("p") }, chosenAccount.token); }
    async function loadUserVaultData(user) {const { content: users } = await getJsonFile(PRIMARY_GITHUB_ACCOUNT.owner, MAIN_REPO_BASE_NAME, CENTER_INDEX_FILE, PRIMARY_GITHUB_ACCOUNT.token);return users ? users[user.email] : null;}
    async function getActiveRepoForUpload() { if (!currentUser || !currentUser.vaultInfo) throw new Error("User vault not loaded."); const lastRepoInfo = currentUser.vaultInfo.repositories[currentUser.vaultInfo.repositories.length - 1]; const { owner, name, accountIndex } = lastRepoInfo; const token = MeraKamara[accountIndex].token; const { data: repoData } = await githubApi(`/repos/${owner}/${name}`, 'GET', null, token); const currentSizeGB = repoData.size / (1024 * 1024); if (currentSizeGB < REPO_SIZE_LIMIT_GB) return lastRepoInfo; const newAccountIndex = Math.floor(Math.random() * MeraKamara.length); const newAccount = MeraKamara[newAccountIndex]; const newRepoNumber = currentUser.vaultInfo.repositories.length + 1; const newRepoName = `${MAIN_REPO_BASE_NAME}-${currentUser.uid.substring(0, 8)}-${newRepoNumber}`; await githubApi('/user/repos', 'POST', { name: newRepoName, private: true }, newAccount.token); const newRepoObject = { owner: newAccount.owner, name: newRepoName, accountIndex: newAccountIndex }; const { content: centralIndex, sha: indexSha } = await getJsonFile(PRIMARY_GITHUB_ACCOUNT.owner, MAIN_REPO_BASE_NAME, CENTER_INDEX_FILE, PRIMARY_GITHUB_ACCOUNT.token); centralIndex[currentUser.email].repositories.push(newRepoObject); const b64content = btoa(JSON.stringify(centralIndex, null, 2)); await githubApi(`/repos/${PRIMARY_GITHUB_ACCOUNT.owner}/${MAIN_REPO_BASE_NAME}/contents/${CENTER_INDEX_FILE}`, 'PUT', { message: `feat: Span repo for user ${currentUser.email}`, content: b64content, sha: indexSha }, PRIMARY_GITHUB_ACCOUNT.token); await githubApi(`/repos/${newAccount.owner}/${newRepoName}/contents/${currentUser.email}/.gitkeep`, 'PUT', { message: `chore: Create initial folder`, content: btoa("p") }, newAccount.token); currentUser.vaultInfo.repositories.push(newRepoObject); return newRepoObject; }
    
    // --- FOLDER & FILE MANAGEMENT ---
    function getCurrentPath() { return [currentUser.email, ...currentPathStack].join('/'); }
    
    btnBack.onclick = () => { currentPathStack.pop(); updateHeaderUI(); refreshFileList(); };
    btnShowUpload.onclick = () => fileInput.click();
    fileInput.addEventListener('change', async () => { if (!fileInput.files.length) return; showToast('Starting upload...', 'info'); const file = fileInput.files[0]; const reader = new FileReader(); reader.onload = async () => { try { const targetRepoInfo = await getActiveRepoForUpload(); const { owner, name, accountIndex } = targetRepoInfo; const token = MeraKamara[accountIndex].token; const path = `${getCurrentPath()}/${file.name}`; const content = btoa(CryptoJS.AES.encrypt(reader.result, GuptDwarKiChabi).toString()); await githubApi(`/repos/${owner}/${name}/contents/${path}`, 'PUT', { message: `feat: Add encrypted file ${file.name}`, content }, token); showToast('Upload complete!', 'success'); await refreshFileList(); } catch (e) { showToast(`Upload failed: ${e.message}`, 'error'); } finally { fileInput.value = ''; } }; reader.readAsDataURL(file); });
    
    function updateView() {
        fileListUl.className = (currentView === 'grid') ? 'file-grid' : 'file-list';
        btnViewToggle.className = (currentView === 'grid') ? 'fa-solid fa-list action-icon' : 'fa-solid fa-grip action-icon';
        localStorage.setItem('fileView', currentView);
        refreshFileList();
    }
    btnViewToggle.onclick = () => { currentView = (currentView === 'grid') ? 'list' : 'grid'; updateView(); };

    async function getVaultContentsWithMetadata() {
        if (!currentUser || !currentUser.vaultInfo) return [];
        let allContents = [];
        const path = getCurrentPath();
        for (const repoInfo of currentUser.vaultInfo.repositories) {
            const { owner, name, accountIndex } = repoInfo;
            const token = MeraKamara[accountIndex].token;
            try {
                const { data: contents } = await githubApi(`/repos/${owner}/${name}/contents/${path}`, 'GET', null, token);
                if (Array.isArray(contents)) {
                    contents.filter(c => c.name !== '.gitkeep' && c.name !== FOLDER_META_FILENAME).forEach(c => {
                        if (!allContents.some(item => item.name === c.name && item.type === c.type)) {
                           allContents.push({ ...c, repoOwner: owner, repoName: name, accountIndex: accountIndex });
                        }
                    });
                }
            } catch (error) { if (!error.message.includes('404')) console.error(`Error fetching from ${name}:`, error); }
        }
        const metadataPromises = allContents.map(async (item) => {
            if (item.type === 'dir') {
                const { content } = await getJsonFile(item.repoOwner, item.repoName, `${item.path}/${FOLDER_META_FILENAME}`, MeraKamara[item.accountIndex].token);
                // NEW: Read color from metadata, provide null fallback
                return { ...item, icon: content?.icon || 'fa-solid fa-folder', color: content?.color || null };
            }
            return item;
        });
        const itemsWithMetadata = await Promise.all(metadataPromises);
        return itemsWithMetadata.sort((a, b) => (a.type === b.type) ? a.name.localeCompare(b.name) : a.type === 'dir' ? -1 : 1);
    }

    async function getAllFilesForStats() {
        if (!currentUser || !currentUser.vaultInfo) return [];
        let allFiles = [];
        const pathsToScan = [currentUser.email];
        const scannedPaths = new Set();
        while (pathsToScan.length > 0) {
            const currentPath = pathsToScan.shift();
            if (scannedPaths.has(currentPath)) continue;
            scannedPaths.add(currentPath);
            for (const repoInfo of currentUser.vaultInfo.repositories) {
                const { owner, name, accountIndex } = repoInfo;
                const token = MeraKamara[accountIndex].token;
                try {
                    const { data: contents } = await githubApi(`/repos/${owner}/${name}/contents/${currentPath}`, 'GET', null, token);
                    if (Array.isArray(contents)) {
                        for (const item of contents) {
                            if (item.type === 'dir') { pathsToScan.push(item.path); } 
                            else if (item.type === 'file' && item.name !== '.gitkeep' && item.name !== FOLDER_META_FILENAME) {
                                if (!allFiles.some(f => f.sha === item.sha)) allFiles.push(item);
                            }
                        }
                    }
                } catch (error) { if (!error.message.includes('404')) console.error(`Error scanning path ${currentPath} in ${name}:`, error); }
            }
        }
        return allFiles;
    }

    async function refreshFileList() { 
        if (!currentUser) return; 
        fileListUl.innerHTML = '<li class="file-item"><div class="file-details"><div class="file-name">Loading...</div></div></li>'; 

        if (currentPathStack.length === 0) {
            storageStatsContainer.style.display = 'block';
            storageStatsContainer.innerHTML = '<div class="total-storage-info">Calculating storage...</div>';
            const allFilesForStats = await getAllFilesForStats();
            if (allFilesForStats.length > 0) {
                let totalSize = 0;
                const typeStats = {};
                allFilesForStats.forEach(file => { totalSize += file.size; const category = getFileCategory(file.name); if (!typeStats[category]) typeStats[category] = { count: 0, size: 0 }; typeStats[category].count++; typeStats[category].size += file.size; });
                let statsHTML = `<div class="total-storage-info">Total Used: <strong>${formatBytes(totalSize)}</strong></div><div class="storage-breakdown">`;
                Object.keys(typeStats).sort().forEach(category => { const stats = typeStats[category]; statsHTML += `<div class="stat-item"><span class="stat-category">${category}</span><span class="stat-details">${stats.count} items &bull; ${formatBytes(stats.size)}</span></div>`; });
                statsHTML += `</div>`;
                storageStatsContainer.innerHTML = statsHTML;
            } else {
                storageStatsContainer.innerHTML = '<div class="total-storage-info">Your vault is empty.</div>';
            }
        } else {
            storageStatsContainer.style.display = 'none';
        }

        const contents = await getVaultContentsWithMetadata();
        const filteredContents = filterItems(contents); 
        fileListUl.innerHTML = ''; 
        if (filteredContents.length === 0) { fileListUl.innerHTML = '<li class="file-item"><div class="file-details"><div class="file-name">This folder is empty.</div></div></li>'; return; }
        
        const fileItemsToProcessThumbs = [];
        filteredContents.forEach(item => {
            const li = document.createElement('li');
            li.className = 'file-item';
            Object.keys(item).forEach(key => li.dataset[key] = typeof item[key] === 'object' ? JSON.stringify(item[key]) : item[key]);
            const actionButtonGrid = `<div class="grid-action-btn"><i class="fa-solid fa-ellipsis-vertical"></i></div>`;
            const actionButtonList = `<div class="file-action-icon"><i class="fa-solid fa-ellipsis"></i></div>`;
            if (item.type === 'dir') {
                 // NEW: Apply custom color style if it exists
                const colorStyle = item.color ? `style="color: ${item.color};"` : '';
                li.innerHTML = (currentView === 'grid') ? `
                    <div class="file-preview"><i class="${item.icon}" ${colorStyle}></i>${actionButtonGrid}</div>
                    <div class="file-details"><div class="file-name">${item.name}</div></div>` : `
                    <div class="file-icon"><i class="${item.icon}" ${colorStyle}></i></div>
                    <div class="file-details"><div class="file-name">${item.name}</div><div class="file-size">Folder</div></div>${actionButtonList}`;
            } else {
                li.innerHTML = (currentView === 'grid') ? `
                    <div class="file-preview">
                        <i class="fa-solid ${getFileIcon(item.name)}"></i>${actionButtonGrid}
                    </div>
                    <div class="file-details"><div class="file-name">${item.name}</div><div class="file-size">${formatBytes(item.size)}</div></div>` : `
                    <div class="file-icon"><i class="fa-solid ${getFileIcon(item.name)}"></i></div>
                    <div class="file-details"><div class="file-name">${item.name}</div><div class="file-size">${formatBytes(item.size)}</div></div>${actionButtonList}`;
                if (currentView === 'grid') fileItemsToProcessThumbs.push(li);
            }
            fileListUl.appendChild(li);
        });
        fileItemsToProcessThumbs.forEach(item => generateAndApplyThumbnail(item));
    }

    fileListUl.addEventListener('click', (e) => {
        const li = e.target.closest('.file-item');
        if (!li || !li.dataset.name) return;
        const itemType = li.dataset.type;
        const actionButton = e.target.closest('.file-action-icon') || e.target.closest('.grid-action-btn');
        if (actionButton) {
            e.stopPropagation();
            currentActionItem = li.dataset;
            showActionSheetFor(itemType);
            return;
        }
        if (itemType === 'dir') {
            currentPathStack.push(li.dataset.name);
            updateHeaderUI();
            refreshFileList();
        } else if (itemType === 'file') {
            handlePreviewClick(li);
        }
    });
    
    function filterItems(items) { 
        if (currentFilter === 'all') return items; 
        const filterMap = { image: ['jpg', 'jpeg', 'png', 'gif', 'bmp'], video: ['mp4', 'avi', 'mov'], doc: ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'txt'] }; 
        const extensions = filterMap[currentFilter]; 
        if (!extensions) return items.filter(i => i.type === 'dir');
        return items.filter(item => item.type === 'dir' || extensions.includes(item.name.split('.').pop().toLowerCase()));
    }
    fileFilterButtons.addEventListener('click', e => { const button = e.target.closest('div[data-filter]'); if (button) { fileFilterButtons.querySelectorAll('div').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); currentFilter = button.dataset.filter; refreshFileList(); } });

    // ======================== FILE ACTIONS & PREVIEW ========================
    function showActionSheetFor(itemType) {
        document.getElementById('actionPreview').style.display = itemType === 'file' ? 'block' : 'none';
        document.getElementById('actionDownload').style.display = 'block';
        document.getElementById('actionDelete').style.display = 'block';
        showModal('action-sheet-modal');
    }

    async function fetchAndDecryptFile(fileDataset) { const { path, sha, size, repoOwner, repoName, accountIndex } = fileDataset; const token = MeraKamara[parseInt(accountIndex)].token; let b64content; if (parseInt(size) / (1024 * 1024) > LARGE_FILE_THRESHOLD_MB) { const { data: blob } = await githubApi(`/repos/${repoOwner}/${repoName}/git/blobs/${sha}`, 'GET', null, token); b64content = blob.content; } else { const { data: meta } = await githubApi(`/repos/${repoOwner}/${repoName}/contents/${path}`, 'GET', null, token); b64content = meta.content; } if (!b64content) throw new Error('Could not retrieve file content.'); const decryptedDataUrl = CryptoJS.AES.decrypt(atob(b64content), GuptDwarKiChabi).toString(CryptoJS.enc.Utf8); if (!decryptedDataUrl) throw new Error('Decryption failed.'); return decryptedDataUrl; }
    
    async function generateAndApplyThumbnail(fileItemElement) {
        const fileData = fileItemElement.dataset;
        const fileName = fileData.name;
        const fileExt = fileName.split('.').pop().toLowerCase();
        const previewContainer = fileItemElement.querySelector('.file-preview');
        const isImage = ['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(fileExt);
        if (!isImage) return; 
        try {
            const decryptedDataUrl = await fetchAndDecryptFile(fileData);
            const img = document.createElement('img');
            img.src = decryptedDataUrl;
            img.alt = `Preview of ${fileName}`;
            img.onload = () => {
                previewContainer.innerHTML = '';
                previewContainer.appendChild(img);
                previewContainer.insertAdjacentHTML('beforeend', `<div class="grid-action-btn"><i class="fa-solid fa-ellipsis-vertical"></i></div>`);
            };
        } catch (error) { console.error(`Failed to generate thumbnail for ${fileName}:`, error); }
    }

    document.getElementById('actionCancel').onclick = () => hideModal('action-sheet-modal');
    document.getElementById('action-sheet-modal').onclick = (e) => { if (e.target === e.currentTarget) hideModal('action-sheet-modal'); };
    document.getElementById('actionPreview').onclick = async () => { hideModal('action-sheet-modal'); if(currentActionItem) handlePreviewClick({dataset: currentActionItem}); };
    document.getElementById('actionDelete').onclick = async () => { hideModal('action-sheet-modal'); if(currentActionItem) handleDeleteClick(currentActionItem); };
    
    document.getElementById('actionDownload').onclick = async () => {
        hideModal('action-sheet-modal');
        if (!currentActionItem) return;
        if (currentActionItem.type === 'file') {
            handleDownloadClick({ dataset: currentActionItem });
        } else if (currentActionItem.type === 'dir') {
            handleDownloadFolderClick(currentActionItem);
        }
    };
    
    async function handlePreviewClick(li) {
        try {
            showToast('Preparing preview...', 'info');
            const decryptedDataUrl = await fetchAndDecryptFile(li.dataset);
            document.getElementById('modalTitle').textContent = li.dataset.name;
            const modalBody = document.getElementById('modalBody');
            pdfControls.style.display = 'none';
            modalBody.innerHTML = '';
            if (decryptedDataUrl.startsWith('data:image')) {
                modalBody.innerHTML = `<img src="${decryptedDataUrl}">`;
            } else if (decryptedDataUrl.startsWith('data:application/pdf')) {
                const pdfData = atob(decryptedDataUrl.substring('data:application/pdf;base64,'.length));
                modalBody.innerHTML = `<p style="padding: 20px;">Loading PDF preview...</p>`;
                pdfjsLib.getDocument({ data: pdfData }).promise.then(function(pdfDoc_) {
                    pdfPreviewState.pdfDoc = pdfDoc_;
                    modalBody.innerHTML = '<canvas id="pdf-canvas"></canvas>';
                    pdfControls.style.display = 'flex';
                    renderPdfPage(pdfPreviewState.pageNum);
                }, function (reason) { showToast('Error loading PDF.', 'error'); modalBody.innerHTML = `<p style="padding: 20px;">Could not load PDF preview.</p>`; });
            } else {
                modalBody.innerHTML = `<p style="padding: 20px;">Preview not available for this file type.</p>`;
            }
            showModal('previewModal');
        } catch (e) { showToast(`Preview Failed: ${e.message}`, 'error'); }
    }
    function renderPdfPage(num) { pdfPreviewState.pageRendering = true; const canvas = document.getElementById('pdf-canvas'); const ctx = canvas.getContext('2d'); pdfPreviewState.pdfDoc.getPage(num).then(function(page) { const desiredWidth = document.getElementById('modalBody').clientWidth; const viewport = page.getViewport({ scale: desiredWidth / page.getViewport({ scale: 1 }).width }); canvas.height = viewport.height; canvas.width = viewport.width; const renderContext = { canvasContext: ctx, viewport: viewport }; page.render(renderContext).promise.then(() => { pdfPreviewState.pageRendering = false; if (pdfPreviewState.pageNumPending !== null) { renderPdfPage(pdfPreviewState.pageNumPending); pdfPreviewState.pageNumPending = null; } }); }); pdfPageInfo.textContent = `Page ${num} of ${pdfPreviewState.pdfDoc.numPages}`; pdfPrevBtn.disabled = num <= 1; pdfNextBtn.disabled = num >= pdfPreviewState.pdfDoc.numPages; }
    function queueRenderPage(num) { if (pdfPreviewState.pageRendering) { pdfPreviewState.pageNumPending = num; } else { renderPdfPage(num); } }
    pdfPrevBtn.onclick = () => { if (pdfPreviewState.pageNum <= 1) return; pdfPreviewState.pageNum--; queueRenderPage(pdfPreviewState.pageNum); };
    pdfNextBtn.onclick = () => { if (pdfPreviewState.pageNum >= pdfPreviewState.pdfDoc.numPages) return; pdfPreviewState.pageNum++; queueRenderPage(pdfPreviewState.pageNum); };
    async function handleDownloadClick(li) { try { const decryptedDataUrl = await fetchAndDecryptFile(li.dataset); const res = await fetch(decryptedDataUrl); const blob = await res.blob(); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = li.dataset.name; a.click(); a.remove(); URL.revokeObjectURL(a.href); showToast('Download started.', 'success'); } catch (e) { showToast(`Download failed: ${e.message}`, 'error'); } }
    
    async function handleDeleteClick(itemData) {
        const { type } = itemData;
        if (type === 'file') {
            await deleteFile(itemData);
        } else if (type === 'dir') {
            await deleteFolder(itemData);
        }
    }

    async function deleteFile(fileData) {
        const { path, sha, name, repoOwner, repoName, accountIndex } = fileData;
        if (!confirm(`Are you sure you want to delete file "${name}"?`)) return;
        try {
            const token = MeraKamara[parseInt(accountIndex)].token;
            await githubApi(`/repos/${repoOwner}/${repoName}/contents/${path}`, 'DELETE', { message: `chore: Delete ${name}`, sha }, token);
            showToast(`"${name}" deleted.`, 'info');
            await refreshFileList();
        } catch (e) { showToast(`Delete failed: ${e.message}`, 'error'); }
    }

    // --- (REWRITTEN & FIXED) Folder Deletion Logic ---
    async function deleteFolder(folderData) {
        const { path, name } = folderData;
        if (!confirm(`Are you sure you want to delete the folder "${name}" and ALL its contents? This cannot be undone.`)) return;
        
        const progressToastId = 'delete-progress-toast';
        showToast(`Finding items in "${name}"...`, 'info', { id: progressToastId, duration: 0 });

        try {
            const allItemsToDelete = await getCompleteListOfItemsInFolder(path);
            if (allItemsToDelete.length === 0) {
                showToast(`Folder "${name}" is empty or does not exist.`, 'info');
                document.getElementById(progressToastId)?.remove();
                await refreshFileList();
                return;
            }

            let successCount = 0;
            let failCount = 0;
            const totalItems = allItemsToDelete.length;

            for (const [index, item] of allItemsToDelete.entries()) {
                showToast(`Deleting ${index + 1} of ${totalItems}: ${item.name}`, 'info', { id: progressToastId, duration: 0 });
                try {
                    const token = MeraKamara[item.accountIndex].token;
                    await githubApi(
                        `/repos/${item.repoOwner}/${item.repoName}/contents/${item.path}`, 
                        'DELETE', 
                        { message: `chore: Delete ${item.name} from folder ${name}`, sha: item.sha }, 
                        token
                    );
                    successCount++;
                } catch (error) {
                    failCount++;
                    console.error(`Failed to delete item: ${item.path}`, error);
                }
            }
            
            document.getElementById(progressToastId)?.remove();
            if (failCount > 0) {
                showToast(`Deleted ${successCount} items from "${name}", but ${failCount} failed.`, 'error');
            } else {
                showToast(`Folder "${name}" deleted successfully.`, 'success');
            }

        } catch (error) {
            document.getElementById(progressToastId)?.remove();
            console.error("Error during folder deletion process:", error);
            showToast(`An error occurred: ${error.message}`, 'error');
        } finally {
            await refreshFileList();
        }
    }

    async function getCompleteListOfItemsInFolder(folderPath) {
        const filesInFolder = await getFolderContentsRecursively(folderPath);
        const metaFilePath = `${folderPath}/${FOLDER_META_FILENAME}`;
        let metaFile = null;
        for (const repoInfo of currentUser.vaultInfo.repositories) {
             const { owner, name: repoName, accountIndex } = repoInfo;
             const token = MeraKamara[accountIndex].token;
             try {
                 const { data } = await githubApi(`/repos/${owner}/${repoName}/contents/${metaFilePath}`, 'GET', null, token);
                 if (data && data.sha) {
                    metaFile = { ...data, repoOwner: owner, repoName, accountIndex };
                    break;
                 }
             } catch(e) { /* Ignore 404s */ }
        }
        const allItems = [...filesInFolder];
        if (metaFile) allItems.push(metaFile);
        return allItems;
    }


    async function getFolderContentsRecursively(folderPath) {
        const allFiles = [];
        const pathsToScan = [folderPath];
        const scannedPaths = new Set();
        
        while(pathsToScan.length > 0) {
            const currentPath = pathsToScan.shift();
            if (scannedPaths.has(currentPath)) continue;
            scannedPaths.add(currentPath);

            for (const repoInfo of currentUser.vaultInfo.repositories) {
                const { owner, name, accountIndex } = repoInfo;
                const token = MeraKamara[accountIndex].token;
                try {
                    const { data: contents } = await githubApi(`/repos/${owner}/${name}/contents/${currentPath}`, 'GET', null, token);
                    if (Array.isArray(contents)) {
                        for (const item of contents) {
                            if (item.type === 'dir') {
                                pathsToScan.push(item.path);
                            } else if (item.type === 'file' && item.name !== FOLDER_META_FILENAME) {
                                allFiles.push({ ...item, repoOwner: owner, repoName: name, accountIndex });
                            }
                        }
                    }
                } catch (error) { 
                    if (!error.message.includes('404')) console.error(`Error scanning path ${currentPath} in ${name}:`, error);
                }
            }
        }
        return allFiles;
    }

    async function handleDownloadFolderClick(folderData) {
        const { path: folderBasePath, name: folderName } = folderData;
        showToast(`Preparing to download "${folderName}"...`, 'info');
        try {
            const zip = new JSZip();
            const filesToZip = await getFolderContentsRecursively(folderBasePath);
            if (filesToZip.length === 0) {
                showToast(`Folder "${folderName}" is empty.`, 'info');
                return;
            }
            showToast(`Found ${filesToZip.length} files. Zipping...`, 'info');
            const dataURLtoBlob = (dataurl) => {
                const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]);
                let n = bstr.length; const u8arr = new Uint8Array(n);
                while(n--) u8arr[n] = bstr.charCodeAt(n);
                return new Blob([u8arr], {type:mime});
            }
            for (const file of filesToZip) {
                try {
                    const decryptedDataUrl = await fetchAndDecryptFile(file);
                    const fileBlob = dataURLtoBlob(decryptedDataUrl);
                    const relativePath = file.path.substring(folderBasePath.length + 1);
                    zip.file(relativePath, fileBlob);
                } catch(e) { console.error(`Skipping file ${file.name} due to error:`, e); }
            }
            const content = await zip.generateAsync({type:"blob"});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = `${folderName}.zip`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(a.href);
            showToast(`"${folderName}.zip" download started.`, 'success');
        } catch (e) { showToast(`Failed to create zip: ${e.message}`, 'error'); }
    }

    function getFileIcon(fileName) { const ext = fileName.split('.').pop().toLowerCase(); const map = { 'pdf': 'fa-file-pdf', 'doc': 'fa-file-word', 'docx': 'fa-file-word', 'xls': 'fa-file-excel', 'xlsx': 'fa-file-excel', 'zip': 'fa-file-zipper', 'rar': 'fa-file-zipper', 'txt': 'fa-file-lines', 'jpg': 'fa-file-image', 'jpeg': 'fa-file-image', 'png': 'fa-file-image', 'gif': 'fa-file-image', 'mp3': 'fa-file-audio', 'wav': 'fa-file-audio', 'mp4': 'fa-file-video', 'mov': 'fa-file-video' }; return map[ext] || 'fa-file'; }
    const closeAndCleanupPreviewModal = () => { if (pdfPreviewState.pdfDoc) { pdfPreviewState.pdfDoc.destroy(); pdfPreviewState.pdfDoc = null; pdfPreviewState.pageNum = 1; } hideModal('previewModal'); };
    document.getElementById('closePreviewModal').onclick = closeAndCleanupPreviewModal;
    previewModal.onclick = (e) => { if (e.target === e.currentTarget) closeAndCleanupPreviewModal(); };

    // --- FOLDER CREATION MODAL LOGIC (with COLOR PICKER) ---
    btnCreateFolder.onclick = () => {
        newFolderNameInput.value = '';
        newFolderColorInput.value = '#007AFF'; // Reset color picker to default
        folderIconSelector.innerHTML = '';
        selectedFolderIcon = FOLDER_ICONS[0];
        const defaultColor = newFolderColorInput.value;
        FOLDER_ICONS.forEach((iconClass, index) => {
            const div = document.createElement('div');
            div.className = 'icon-choice';
            if (index === 0) div.classList.add('selected');
            div.dataset.icon = iconClass;
            div.innerHTML = `<i class="${iconClass}" style="color: ${defaultColor};"></i>`;
            folderIconSelector.appendChild(div);
        });
        showModal('folderCreationModal');
    };
    folderIconSelector.addEventListener('click', (e) => {
        const choice = e.target.closest('.icon-choice');
        if (!choice) return;
        folderIconSelector.querySelectorAll('.icon-choice').forEach(c => c.classList.remove('selected'));
        choice.classList.add('selected');
        selectedFolderIcon = choice.dataset.icon;
    });
    // NEW: Live color preview for icons in modal
    newFolderColorInput.addEventListener('input', (e) => {
        const newColor = e.target.value;
        folderIconSelector.querySelectorAll('.icon-choice i').forEach(icon => {
            icon.style.color = newColor;
        });
    });
    cancelFolderCreationBtn.onclick = () => hideModal('folderCreationModal');
    folderCreationModal.querySelector('.modal-close-btn').onclick = () => hideModal('folderCreationModal');
    confirmFolderCreationBtn.onclick = async () => {
        const folderName = newFolderNameInput.value.trim();
        if (!folderName || folderName.includes('/') || folderName.includes('\\')) { showToast("Invalid folder name.", "error"); return; }
        confirmFolderCreationBtn.disabled = true;
        confirmFolderCreationBtn.textContent = 'Creating...';
        try {
            const targetRepoInfo = await getActiveRepoForUpload();
            const path = `${getCurrentPath()}/${folderName}/${FOLDER_META_FILENAME}`;
            const token = MeraKamara[targetRepoInfo.accountIndex].token;
            const folderColor = newFolderColorInput.value; // Get the chosen color
            const content = btoa(JSON.stringify({ 
                icon: selectedFolderIcon, 
                color: folderColor, // Save the color in metadata
                createdAt: new Date().toISOString() 
            }));
            await githubApi(`/repos/${targetRepoInfo.owner}/${targetRepoInfo.name}/contents/${path}`, 'PUT', { message: `feat: Create folder ${folderName}`, content }, token);
            showToast(`Folder "${folderName}" created.`, 'success');
            hideModal('folderCreationModal');
            await refreshFileList();
        } catch (error) { showToast(`Failed to create folder: ${error.message}`, 'error'); } finally {
            confirmFolderCreationBtn.disabled = false;
            confirmFolderCreationBtn.textContent = 'Create';
        }
    };

    // ======================== SHARE LOGIC ========================
    function updateShareProgressBar(progress) { progressBar.style.width = `${progress}%`; }
    function* generateChunks(file) { let offset = 0; while (offset < file.size) { yield file.slice(offset, offset + CHUNK_SIZE); offset += CHUNK_SIZE; } }
    function chunkToBase64(chunk) { return new Promise((resolve) => { const reader = new FileReader(); reader.onloadend = () => resolve(reader.result); reader.readAsDataURL(chunk); }); }
    shareModeToggle.addEventListener('click', (e) => { const button = e.target.closest('div[data-mode]'); if (button && !button.classList.contains('active')) { shareModeToggle.querySelectorAll('div').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); const isSend = button.dataset.mode === 'send'; shareSendMode.style.display = isSend ? 'block' : 'none'; shareInboxMode.style.display = isSend ? 'none' : 'block'; } });
    sendButton.onclick = async function() { const receiverEmail = receiverEmailInput.value; if (!fileToShare || !receiverEmail) { showToast('Select a file and enter a receiver', 'error'); return; } sendButton.disabled = true; sendButton.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i><span>Sending...</span>`; progressContainer.style.display = 'block'; let file; try { if (fileToShare.source === 'vault') { showToast('Decrypting file from vault...'); const decryptedDataUrl = await fetchAndDecryptFile(fileToShare.data); const res = await fetch(decryptedDataUrl); const blob = await res.blob(); file = new File([blob], fileToShare.data.name, { type: blob.type }); } else { file = fileToShare.file; } const usersSnapshot = await get(ref(database, 'dropit_users')); const users = usersSnapshot.val(); const receiverUid = Object.keys(users).find(uid => users[uid].email === receiverEmail); if (!receiverUid) throw new Error('Receiver not found'); const fileRef = push(ref(database, `files/${receiverUid}`)); const fileId = fileRef.key; const totalChunks = Math.ceil(file.size / CHUNK_SIZE); await set(fileRef, { name: file.name, type: file.type, size: file.size, sender: auth.currentUser.email, status: 'sending', totalChunks: totalChunks }); let chunkIndex = 0; for (const chunk of generateChunks(file)) { const base64Chunk = await chunkToBase64(chunk); await set(ref(database, `fileChunks/${receiverUid}/${fileId}/${chunkIndex}`), { data: base64Chunk }); chunkIndex++; updateShareProgressBar((chunkIndex / totalChunks) * 100); } await update(fileRef, { status: 'ready-for-download' }); showToast('File sent successfully!', 'success'); clearFileSelection(); receiverEmailInput.value = ''; } catch (error) { showToast(error.message || 'Error sending file', 'error'); } finally { sendButton.disabled = false; sendButton.innerHTML = `<i class="fa-solid fa-paper-plane"></i><span>Send File</span>`; progressContainer.style.display = 'none'; updateShareProgressBar(0); } }
    function setupFileListeners(user) { onValue(ref(database, `files/${user.uid}`), (snapshot) => { incomingFilesDiv.innerHTML = ''; if (!snapshot.exists()) { incomingFilesDiv.innerHTML = `<li class="file-item"><div class="file-details"><div class="file-name">Your inbox is empty.</div></div></li>`; return; } snapshot.forEach((childSnapshot) => { const fileKey = childSnapshot.key; const fileData = childSnapshot.val(); if (fileData.status === 'ready-for-download') { const fileElement = document.createElement('li'); fileElement.className = 'incoming-file-item'; fileElement.innerHTML = `<div class="file-icon"><i class="fa-solid ${getFileIcon(fileData.name)}"></i></div><div class="file-details"><div class="file-name">${fileData.name}</div><div class="file-size">from ${fileData.sender}</div></div><div class="incoming-file-actions"><button onclick="window.acceptFile('${fileKey}')" class="accept-btn"><i class="fa-solid fa-check"></i></button><button onclick="window.rejectFile('${fileKey}')" class="reject-btn"><i class="fa-solid fa-xmark"></i></button></div>`; incomingFilesDiv.appendChild(fileElement); } }); }); }
    window.acceptFile = async function(fileKey) { const user = auth.currentUser; const fileData = (await get(ref(database, `files/${user.uid}/${fileKey}`))).val(); if (!fileData) return; showToast(`Downloading ${fileData.name}...`, 'info'); try { const binaryChunks = []; for (let i = 0; i < fileData.totalChunks; i++) { const chunkSnapshot = await get(ref(database, `fileChunks/${user.uid}/${fileKey}/${i}`)); const chunk = chunkSnapshot.val(); if (chunk && chunk.data) { const base64Data = chunk.data.split(',')[1]; const binaryString = atob(base64Data); const bytes = new Uint8Array(binaryString.length); for (let j = 0; j < binaryString.length; j++) bytes[j] = binaryString.charCodeAt(j); binaryChunks.push(bytes); } } const blob = new Blob(binaryChunks, { type: fileData.type }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = fileData.name; a.click(); URL.revokeObjectURL(a.href); await remove(ref(database, `fileChunks/${user.uid}/${fileKey}`)); await remove(ref(database, `files/${user.uid}/${fileKey}`)); showToast('Download complete!', 'success'); } catch (error) { showToast('Download failed', 'error'); } }
    window.rejectFile = async function(fileKey) { const user = auth.currentUser; await remove(ref(database, `fileChunks/${user.uid}/${fileKey}`)); await remove(ref(database, `files/${user.uid}/${fileKey}`)); showToast('File rejected.', 'info'); }
    selectFromVaultBtn.onclick = async () => { vaultFileListForSharing.innerHTML = '<li class="file-item"><div class="file-details"><div class="file-name">Loading vault files...</div></div></li>'; showModal('vaultSelectModal'); const allFiles = await getAllFilesForStats(); vaultFileListForSharing.innerHTML = ''; if (allFiles.length === 0) { vaultFileListForSharing.innerHTML = '<li class="file-item"><div class="file-details"><div class="file-name">Your vault is empty.</div></div></li>'; return; } allFiles.forEach(f => { const li = document.createElement('li'); li.className = 'file-item'; li.style.cursor = 'pointer'; Object.keys(f).forEach(key => li.dataset[key] = f[key]); li.innerHTML = `<div class="file-icon"><i class="fa-solid ${getFileIcon(f.name)}"></i></div><div class="file-details"><div class="file-name">${f.name}</div><div class="file-size">${formatBytes(f.size)}</div></div>`; li.onclick = () => { fileToShare = { source: 'vault', data: li.dataset }; updateSelectedFileUI(li.dataset.name); hideModal('vaultSelectModal'); }; vaultFileListForSharing.appendChild(li); }); };
    document.getElementById('closeVaultSelectModal').onclick = () => hideModal('vaultSelectModal');
    vaultSelectModal.onclick = (e) => { if (e.target === e.currentTarget) hideModal('vaultSelectModal'); };
    const updateSelectedFileUI = (name) => { selectedFileName.textContent = name; selectedShareFileDisplay.style.display = 'flex'; shareFileInput.value = ''; }
    const clearFileSelection = () => { fileToShare = null; selectedShareFileDisplay.style.display = 'none'; shareFileInput.value = ''; }
    clearSelectionBtn.onclick = clearFileSelection;
    shareFileInput.addEventListener('change', () => { if (shareFileInput.files.length > 0) { fileToShare = { source: 'local', file: shareFileInput.files[0] }; updateSelectedFileUI(fileToShare.file.name); } });
    const dropZone = document.querySelector('.drop-zone');
    dropZone.addEventListener('dragenter', (e) => { e.preventDefault(); e.stopPropagation(); dropZone.style.backgroundColor = 'var(--ios-mid-gray)'; });
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); });
    dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); dropZone.style.backgroundColor = 'var(--ios-white)'; });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); e.stopPropagation(); dropZone.style.backgroundColor = 'var(--ios-white)'; if (e.dataTransfer.files.length > 0) { shareFileInput.files = e.dataTransfer.files; fileToShare = { source: 'local', file: shareFileInput.files[0] }; updateSelectedFileUI(fileToShare.file.name); showToast(`${e.dataTransfer.files.length} file(s) selected.`, 'info'); } });
</script>
</body>
</html>
